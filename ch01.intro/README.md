# 關於 Go 語言的介紹

計算機在演化，但是編程語言並沒有以同樣的速度演化。現今手機 CPU 核數可能都多於我們使用的第一台電腦。然而我們依舊使用單核設計的技術在編程。

編程的技術同樣在演化。大部分程序不再由單個開發者完成，而是由處於不同時區、不同時間段工作的一組人來完成。大項目分解成小項目，指派給不同程序員，程序員開發完成後，再以可以在各個應用程序中交叉使用的庫或者包的形式，提交給整個團隊。

Go 語言是一種讓代碼分享更容易的編程語言。Go 自帶一些工具，讓使用別人寫的包更容易，並且 Go 語言也讓分享自己寫的包更容易。

Go 語言對傳統的物件導向開發進行了重新思考，並且提供了更高效的復用代碼的手段。Go 語言還讓用戶能更高效利用昂貴伺服器上所有核心，並且它編譯大型項目的速度也很快。

Go 語言附帶的工具可以讓開發人員的生活變得更簡單。

## 用 Go 語言解決現代編程難題

開發人員在為項目選擇語言時，不得不在快速開發和性能之間做出選擇：

- C/C++ 這類語言提供了很快地執行速度
- Ruby 和 Python 擅長快速開發

Go 語言在這兩者間架起了橋樑，不僅提供高性能語言，同時也讓開發更快速

作為一門語言，Go 不僅定義了能做什麼，還定義了不能做什麼。

Go 語言的語法簡潔到只有幾個關鍵字，便於記憶。

Go 語言的編譯器速度飛快，甚至感覺不到在編譯。

Go 語言內置並發機制，所以不用被迫使用特定的線程庫，就能讓軟件擴展，使用更多資源。

Go 語言類型系統簡單高效，不需要為物件導向開發付出額外的心智，讓開發者能專注於代碼復用。

Go 語言自帶垃圾回收器，不需用戶自己管理內存。

讓我們快速瀏覽一下這些關鍵特性：

### 開發速度

一個大型 C/C++ 項目編譯花費的時間比喝杯咖啡的時間還長。

> 程序員合理地逃避工作最常用的藉口：“我的代碼正在編譯呢。”

Go 語言使用了更加智能的編譯器，並簡化了解決依賴的算法，最終提供了更快的編譯速度。編譯 Go 程序時，**編譯器只會關注那些直接被引用的庫**，而不是像 Java、C 和 C++ 那樣，要遍歷依賴鏈中所有依賴的庫。因此，很多 Go 程序可以在一秒內編譯完。在現代硬件上，編譯整個 Go 語言的源碼樹只需要 20 秒。

因為沒有從編譯代碼到執行代碼的中間過程，用動態語言編寫應用可以快速看到輸出。代價是，動態語言不提供靜態語言提供的類型安全特性，不得不用大量測試套件避免運行出現類型錯誤的 bug。

想像一下 JavaScript 的函數接收 ID 欄位。這參數應該是整數，是字符串，還是一個 UUID？要想知道答案，只能去看源代碼。

### 並發

作為程序員，要開發出能充分利用硬件資源的應用程序是一件很難的事情。現代計算機有許多核，但是大部分編程語言都沒有有效的工具讓程序可以輕易利用這些資源。這些語言需要寫大量的線程同步代碼來利用多個核，很容易導致錯誤。

Go 語言對並發的支持是這門語言最重要的特性之一。goroutine 很像線程，但是它佔用的內存遠小於線程，使用它需要的代碼更少。channel 是一種內置的數據結構，可以讓用戶在不同的 goroutine 之間同步發送具有類型的消息。這讓編程模型更傾向於在 goroutine 之間發送消息，而不是讓多個 goroutine 爭奪同一個數據的使用權。讓我們看看這些特性細節：

#### 1. goroutine

goroutine 是可以與其他 goroutine 並行執行的函數，同時也會與主程序 (程序的入口) 並行執行。在其他的編程語言中，你需要用線程來完成同樣的事情，而在 Go 語言中會使用同一個線程來執行多個 goroutine。例如，用戶在寫一個 Web Server，希望同時處理不同的 Web 請求，如果使用 C 和 Java，不得不寫大量的額外代碼來使用線程。在 Go 語言中，net/http 庫直接使用內置的 goroutine。每個接收到的請求都自動在其自己的 goroutine 裡處理。goroutine 使用的內存比線程更少，Go 語言運行時會自動在配置的一組邏輯處理器上調度執行 goroutine。每個邏輯處理器綁定到一個操作系統線程上。這讓用戶的應用程序執行效率更高，而開發工作量顯著減少。

如果想在執行一段代碼的同時，並行去做另外一件事情，goroutine 是很好的選擇。下面是一個簡單例子：

```go
package main

func log(msg string) {
  // ... 這裡是一些記錄日誌的代碼
}

// 代碼裡有些地方檢測到了錯誤
go log("發生了可怕的事情")
```

關鍵字 go 是唯一需要去編寫的代碼，調度 log 函數作為獨立的 goroutine 去運行，以便與其他 goroutine 並行執行。這意味著應用程序的其餘部分會與記錄日誌並行執行，通常這種並行能讓最終用戶覺得性能更好。就像之前說的，goroutine 佔用的資源更少，所以常常能啟動成千上萬個 goroutine。我們會在 chap 06 更加深入探討 goroutine 和併發。

#### 2. 通道

通道是一種數據結構，可以讓 goroutine 之間進行安全的數據通信。通道可以幫用戶避免其他語言裡常見的共享內存訪問的問題。

併發最難部分就是要確保其他併發運行的的進程、線程或 goroutine 不會意外修改用戶的數據。當不同的線程在沒有同步保護的情況下修改同一個數據時，總會發生災難。在其他語言中，如果使用全局變數或共享內存，必須使用複雜的鎖規則來防止對同一個變數的不同步修改。

為解決這個問題，通道提供了一種新模式，從而保證併發修改時的數據安全。通道這一模式保證同一時刻只會有一個 goroutine 修改數據。通道用於在幾個運行的 goroutine 之間發送數據。想像一個應用程序，有多個進程需要順序讀取或修改某個數據，使用 goroutine 和通道，可以為這個過程建立安全的模型。

在兩個 goroutine 透過通道傳輸數據是同步的，一旦傳輸完成，兩個 goroutine 都會知道數據已經完成傳輸。這樣的 goroutine 之間安全傳輸數據的方法不需要任何鎖或者同步機制。

需強調的是，通道並不提供跨 goroutine 的數據訪問保護機制。如果透過通道傳輸數據的一份副本，那麼每個 goroutine 都持有一份副本，各自對自己的副本做修改是安全的。當傳輸的是指向數據的指針時，如果讀和寫是由不同的 goroutine 完成的，每個 goroutine 依舊需要額外的同步動作。

### Go 語言的類型系統

Go 語言提供靈活、無繼承的類型系統，無需降低運行性能就能最大程度上復用代碼。這個類型系統依然支持物件導向開發，但避免了傳統物件導向的問題。如果你曾經在複雜的 Java 或 C++ 程序上花數週時間考慮如何抽象類和接口，你就能意識到 Go 語言的類型系統有多簡單。Go 開發者使用組合 (composition) 設計模式，只需簡單地將一個類型嵌入到另一個類型，就能復用所有功能。其他語言也能使用組合，但是不得不和繼承綁在一起使用，結果使整個用法非常複雜，很難使用。在 Go 語言中，一個類型由其他更微小的類型組合而成，避免了傳統的基於繼承的模型。

另外，Go 語言還有獨特的接口實現機制，允許用戶對行為進行建模，而不是對類型進行建模。在 Go 語言中，不需要聲明某個類型實現了某個接口，編譯器會判斷一個類型的實例是否符合正在使用的接口。Go 標準庫裡的很多接口都非常簡單，只開放幾個函數。從實踐上講，尤其對那些使用類似 Java 的物件導向語言的人來說，需要一些時間才能習慣這些特性。

#### 1. 類型簡單

Go 語言不僅有類似 int 和 string 這樣的內置類型，還支持用戶定義的類型。在 Go 語言中，用戶定義的類型通常包含一組帶類型的欄位，用於存儲數據。Go 語言的用戶定義的類型看起來和 C 語言的結構很像，用起來也很相似。不過 Go 語言的類型可以聲明操作該類型數據的方法。傳統語言使用繼承來擴展結構——

- Client 繼承自 User
- User 繼承自 Entity

Go 語言與此不同，Go 開發者構建更小的類型——

- Customer 和 Admin

然後把這些小類型組合成更大的類型

#### 2. Go 接口對一組行為建模

接口用於描述類型的行為。如果一個類型的實例實現了一個接口，意味著這個實例可以執行一組特定的行為。你甚至不需要去聲明這個實例實現某個接口，只需要實現這組行為就好。其他的語言把這個特性叫做**鴨子類型**——如果它叫起來像鴨子，那它就可能是只鴨子。Go 語言的接口也是這麼做的。在 Go 語言中，如果一個類型實現了一個接口的所有方法，那麼這個類型的實例就可以存儲在這個接口類型的實例中，不需額外聲明。

在類似 Java 這種嚴格的物件導向語言中，所有設計都圍繞接口展開。在編碼前，用戶不得不思考一個龐大的繼承鏈。且 Java 要實現這個接口，要求用戶的類必須滿足接口裡所有約束，並且顯式聲明這個類實現了這個接口。而 Go 語言的接口一般只會描述一個單一的動作。在 Go 語言中，最常使用的接口之一是 io.Reader。這個接口提供了一個簡單的方法，來聲明一個類型有數據可以讀取。標準庫內的其他函數都能理解這個接口。這個接口定義如下：

```go
type Reader interface {
  Read(p []byte) (n int, err error)
}
```

為了實現 io.Reader 這個接口，你只需要實現一個 Read 方法，這個方法接受一個 byte 切片，返回一個整數和可能出現的錯誤。

這和傳統的物件導向編程語言的接口系統有本質的區別。Go 語言的接口更小，只傾向於定義一個單一的動作。實際使用中，這更有利於使用組合來復用代碼。用戶幾乎可以給所有包含數據的類型實現 io.Reader 接口，然後把這個類型的實例傳給任意一個知道如何讀取 io.Reader 的 Go 函數。

Go 語言的整個網絡庫都使用了 io.Reader 接口，這樣可以將程序的功能和不同網絡的實現分離。這樣的接口用起來有趣、優雅且自由。文件、緩衝區、套接字以及其他的數據源都實現了 io.Reader 接口。使用同一個接口，可以高效地操作數據，而不用考慮到底數據來自哪裡。

### 內存管理

不當的內存管理會導致程序崩潰或者內存泄露，甚至讓整個操作系統崩潰。Go 語言擁有現代化的垃圾回收機制，能幫你解決這個難題。在其他系統語言 (如 C 或 C++) 中，使用內存前要先分配這段內存，而且使用完畢後將其釋放掉。哪怕只做錯一件事，都可能導致程序崩潰或內存泄露。可惜，追蹤內存是否還被使用本身就是十分艱難的事情，而要想支持多線程和高併發，更是讓這件事難上加難。雖然 Go 語言的垃圾回收會有一些額外的開銷，但是編程時，能顯著降低開發難度。Go 語言把無趣的內存管理交給專業的編譯器去做，讓程序員專注於更有趣的事情。

## 你好，Go

```go
package main // Go 程序都組織成包

import "fmt" // import 語句用於導入外部代碼。標準庫中的 fmt 包用於格式化並輸出數據

func main() { // 像 C 語言一樣，main 函數是程序執行的入口
  fmt.Println("Hello world!")
}
```

無須在機器上安裝 Go 語言，在瀏覽器中就可以使用幾乎所有 Go 語言的功能。

### 介紹 Go Playground

Go Playground 允許在瀏覽器裡編輯並運行 Go 語言代碼。

[https://play.golang.org/](https://play.golang.org/)

可用 Share 得到一個分享的網址，任何人都能打開這個連接。可用來學習寫東西、尋求幫助或演示想法，Go playground 是非常好的方式。

## 小結

- Go 語言是現代的、快速的，帶有一個強大的標準庫
- Go 語言內置對併發的支持
- Go 語言使用接口作為代碼復用的基礎模塊